/**
 * Facebook Firefox Toolbar Software License
 * Copyright (c) 2007 Facebook, Inc.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (which, together with any graphical images included with such
 * software, are collectively referred to below as the "Software") to (a) use,
 * reproduce, display, distribute, execute, and transmit the Software, (b)
 * prepare derivative works of the Software (excluding any graphical images
 * included with the Software, which may not be modified or altered), and (c)
 * permit third-parties to whom the Software is furnished to do so, all
 * subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * Facebook, Inc. retains ownership of the Software and all associated
 * intellectual property rights.  All rights not expressly granted in this
 * license are reserved by Facebook, Inc.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const Cc = Components.classes;
const Ci = Components.interfaces;
const CC = Components.Constructor;
const Cu = Components.utils;

const FileInputStream = CC("@mozilla.org/network/file-input-stream;1",
                           "nsIFileInputStream",
                           "init");
const StringInputStream = CC("@mozilla.org/io/string-input-stream;1",
                             "nsIStringInputStream")

// Debugging.
function d(s) {
  dump(s + "\n");
}

/**
 * This object (singleton) represent the list of photos that will be uploaded
 * or that can be edited.
 */
var PhotoSet = {
  // XXX photos are nsIFile objects now. This may change once resizing or
  // metadata editing is implemented.
  _photos: [],
  _listeners: [],

  add: function(aFiles) {
    Array.prototype.push.apply(this._photos, aFiles)

    this._notifyChanged();
  },

  removeAll: function() {
    this._photos = [];
    this._notifyChanged();
  },

  get photos() {
    return this._photos;
  },

  _notifyChanged: function() {
    this._listeners.forEach(function(listener) {
      listener.call(this);
    }, this);
  },

  addChangedListener: function(aListener) {
    this._listeners.push(aListener);
  },

  removeChangedListener: function(aListener) {
    this._listeners = this._listeners.filter(hasFilter);
    function hasFilter(listener) {
      return listener != aListener;
    }
  },

  _uploadFile: function(file, onComplete, onError) {
    var fbSvc = Cc['@facebook.com/facebook-service;1'].
                getService(Ci.fbIFacebookService);

    // Hack for accessing private members.
    var fbSvc_ = fbSvc.wrappedJSObject;
    d("file is " + file);

    var params = {};

    // method specific:
    params.method = "facebook.photos.upload";

    // TODO: this should be refactored with callMethod in the XPCOM component.
    params.session_key = fbSvc_._sessionKey;
    params.api_key = fbSvc.apiKey;
    params.v = "1.0";
    var callId = Date.now();
    if (callId <= fbSvc_._lastCallId) {
        callId = fbSvc_._lastCallId + 1;
    }
    fbSvc_._lastCallId = callId;
    params.call_id = callId;
    params.format = "JSON";

    // Builds another array of params in the format accepted by generateSig()
    var paramsForSig = [];
    for (let [name, value] in Iterator(params)) {
      paramsForSig.push(name + "=" + value);
    }
    params.sig = fbSvc_.generateSig(paramsForSig);

    const BOUNDARY = "facebookPhotoUploaderBoundary";

    var mis = Cc["@mozilla.org/io/multiplex-input-stream;1"].
              createInstance(Ci.nsIMultiplexInputStream);

    const PR_RDONLY = 0x01;
    var fis = new FileInputStream(file, PR_RDONLY, 0444, null);

    var bis = Cc["@mozilla.org/network/buffered-input-stream;1"].
              createInstance(Ci.nsIBufferedInputStream);
    bis.init(fis, 4096);

    var sis = new StringInputStream();
    var header = "";

    for (let [name, value] in Iterator(params)) {
      header += "--" + BOUNDARY + "\r\n";
      header += "Content-disposition: form-data; name=\"" + name + "\"\r\n\r\n";
      header += value;
      header += "\r\n";
    }

    d("header:\n" + header);

    header += "--" + BOUNDARY + "\r\n";
    header += "Content-disposition: form-data;name=\"filename\"; filename=\"" +
              file.leafName + "\"\r\n";
    // Apparently Facebook accepts binay content type and will sniff the file
    // for the correct image mime type.
    header += "Content-Type: application/octet-stream\r\n";
    header += "\r\n";

    sis.setData(header, header.length);

    var endsis = new StringInputStream();
    var bs = "\r\n--" + BOUNDARY + "--\r\n";
    endsis.setData(bs, bs.length);

    mis.appendStream(sis);
    mis.appendStream(bis);
    mis.appendStream(endsis);

    var xhr = new XMLHttpRequest();

    const RESTSERVER = 'http://api.facebook.com/restserver.php';
    xhr.open("POST", RESTSERVER);

    xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
    xhr.setRequestHeader("MIME-version", "1.0");

    xhr.onreadystatechange = function(event) {
      d("onreadstatechange " + xhr.readyState)
      if (xhr.readyState != 4)
        return;

      // XXX 3.0 compat
      try {
        var data = JSON.parse(xhr.responseText);
      } catch(e) {
        onError("Failed to parse JSON", xhr.reponseText);
        return;
      }
      // TODO: refactor with facebook.js::callMethod
      if (typeof data.error_code != "undefined") {
        onError("Server returned an error: " + data.error_msg, data);
        return;
      }
      onComplete();
    }
    xhr.onerror = function(event) {
      onError("XMLHttpRequest error", event);
    }

    // progress on transfers from the server to the client (downloads)
    function updateProgress(evt) {
      d("updateProgress");
    }

    // XXX progress events do not work
    xhr.onprogress = updateProgress;
    xhr.upload.onprogress = updateProgress;

    xhr.send(mis);
  },

  upload: function(progressCallback, errorCallback) {
    var toUpload = this._photos;
    this._photos = [];
    this._notifyChanged();

    var total = toUpload.length;
    var done = 0;

    var self = this;
    function doUpload() {
      if (done == total) {
        d("How could that happen?");
        return;
      }
      var photo = toUpload.shift();
      if (!photo) {
        d("How could that happen?");
        return;
      }

      self._uploadFile(photo, function() {
        done++;
        progressCallback(done / total * 100);
        if (done < total)
          doUpload();
      }, function() {
        errorCallback.apply(this, arguments);
      });
    }
    doUpload();
  }
};

/**
 * Manages the UI for displaying and manipulating the list of photos.
 */
var PhotoPanel = {
  init: function() {
    PhotoSet.addChangedListener(this.photosChanged);
  },
  uninit: function() {
    PhotoSet.removeChangedListener(this.photosChanged);
  },
  photosChanged: function() {
    d("PhotosChanged ");

    var panelDoc = document.getElementById("photopanel").contentDocument;
    var photoboxTemplate = panelDoc.getElementById("photobox-template")
    var photos = PhotoSet.photos;

    // TODO: 3.0 compat
    var toDelete = panelDoc.querySelectorAll(".photobox:not([id=photobox-template])");
    for (let i = toDelete.length; --i >= 0;)
      toDelete[i].parentNode.removeChild(toDelete[i]);

    panelDoc.querySelectorAll(".photobox:not([id=photobox-template])")
    var ios = Cc["@mozilla.org/network/io-service;1"].
              getService(Ci.nsIIOService);

    photos.forEach(function(photo) {
      var newBox = photoboxTemplate.cloneNode(true);
      newBox.removeAttribute("id");

      var uri = ios.newFileURI(photo);

      // TODO: 3.0 compat
      newBox.querySelector("img").src = uri.spec;
      photoboxTemplate.parentNode.insertBefore(newBox, photoboxTemplate);
    });
  }
};

/**
 * Manages the Photo upload window.
 */
var PhotoUpload = {
  get _stringBundle() {
    delete this._stringBundle;
    return this._stringBundle = document.getElementById("facebookStringBundle");
  },

  init: function() {
    PhotoPanel.init();
  },

  uninit: function() {
    PhotoPanel.uninit();
  },

  _getAlbums: function() {
    var fbSvc = Cc['@facebook.com/facebook-service;1'].
                getService(Ci.fbIFacebookService);

    // XXX wrappedJSObject hack because the method is not exposed.
    fbSvc.wrappedJSObject.callMethod('facebook.photos.getAlbums',
                                     ["uid=" + fbSvc.wrappedJSObject._uid],
                                     function(albums) {
      d("Got response: " + albums);
      for each (let album in albums) {
        d("alb " + album.aid + " - " + album.name + " -created: " + album.created);
      }
    });
  },

  addPhotos: function() {
    var fp = Cc["@mozilla.org/filepicker;1"].
             createInstance(Ci.nsIFilePicker);
    fp.init(window, this._stringBundle.getString("photoupload.fp.title"),
            Ci.nsIFilePicker.modeOpenMultiple);
    fp.appendFilters(Ci.nsIFilePicker.filterImages);
    if (fp.show() != Ci.nsIFilePicker.returnCancel) {
      var files = [];
      var filesEnum = fp.files;
      while (filesEnum.hasMoreElements()) {
        files.push(filesEnum.getNext());
      }
      PhotoSet.add(files);
    }
  },

  removeSelectedPhotos: function() {
    alert("TODO");
  },

  removeAllPhotos: function() {
    PhotoSet.removeAll();
  },

  cancelUpload: function() {
    alert("TODO");
  },

  upload: function() {
    // TODO: should disable the button if there are no photos.
    if (PhotoSet.photos.length == 0) {
      alert("Please add some Photos");
      return;
    }

    var uploadStatus = document.getElementById("uploadStatus")
    var uploadDeck = document.getElementById("uploadDeck");
    var progress = document.getElementById("uploadProgress");

    uploadDeck.selectedIndex = 1;
    uploadStatus.className = "upload-status";
    uploadStatus.value = "";

    PhotoSet.upload(function(percent) {
      d("Got progress " + percent);

      progress.value = percent;
      if (percent < 100)
        return;

      uploadDeck.selectedIndex = 0;
      progress.value = 0;
      // TODO: l10n
      uploadStatus.value = "Upload completed successfully";

      if (document.getElementById("closeAfterUpload").value) {
        d("TODO: close document and open album page");
        //window.close();
      }
    }, function(message, detail) {
      uploadDeck.selectedIndex = 0;
      // TODO: l10n
      alert("Failed to upload photos\n\nTechnical Detail: " + message);
      uploadStatus.className += " error";
      uploadStatus.value = "Upload failed. Technical Detail: " + message;
    });
  }
};
