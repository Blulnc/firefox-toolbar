/**
 * Facebook Firefox Toolbar Software License
 * Copyright (c) 2009 Facebook, Inc.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (which, together with any graphical images included with such
 * software, are collectively referred to below as the "Software") to (a) use,
 * reproduce, display, distribute, execute, and transmit the Software, (b)
 * prepare derivative works of the Software (excluding any graphical images
 * included with the Software, which may not be modified or altered), and (c)
 * permit third-parties to whom the Software is furnished to do so, all
 * subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * Facebook, Inc. retains ownership of the Software and all associated
 * intellectual property rights.  All rights not expressly granted in this
 * license are reserved by Facebook, Inc.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const Cc = Components.classes;
const Ci = Components.interfaces;
const CC = Components.Constructor;
const Cu = Components.utils;

const FileInputStream = CC("@mozilla.org/network/file-input-stream;1",
                           "nsIFileInputStream",
                           "init");
const StringInputStream = CC("@mozilla.org/io/string-input-stream;1",
                             "nsIStringInputStream")

// Keep this in sync with the albumid attribute of the default album in photoupload.xul
const DEFAULT_ALBUM = "-1";

// Compatibility with Firefox 3.0 that doesn't have native JSON.
// TODO: remove this once the Facebook component is used for requests.
if (typeof(JSON) == "undefined") {
  Components.utils.import("resource://gre/modules/JSON.jsm");
  JSON.parse = JSON.fromString;
  JSON.stringify = JSON.toString;
}

// Debugging.
function d(s) {
  dump(s + "\n");
}

/**
 * This objects represents a photo that is going to be uploaded.
 */
function Photo(/* nsIFile */ file) {
  // photos are stored as nsIFile objects. This may change when resizing or
  // photo editing (rotate, ...) is implemented.
  this.file = file;
  this.caption = "";
  d(" Constructed " + this.file);
};

Photo.prototype = {
  get url() {
    var ios = Cc["@mozilla.org/network/io-service;1"].
              getService(Ci.nsIIOService);
    d("this " + this + " FILE " + this.file);
    return ios.newFileURI(this.file).spec;
  }
};

const BOUNDARY = "facebookPhotoUploaderBoundary";

/**
 * This object (singleton) represent the list of photos that will be uploaded
 * or that can be edited.
 */
var PhotoSet = {
  // Array of Photo objects.
  _photos: [],
  // Currently selected Photo object.
  _selected: null,
  _listeners: [],
  _cancelled: false,

  add: function(aFiles) {
    Array.prototype.push.apply(this._photos, aFiles)

    this._notifyChanged();
  },

  _updateSelected: function() {
    var p = this._photos.filter(function(p) p == this._selected);
    if (p.length > 1) {
      d("ERROR: more that once selected photo?");
      return;
    }
    if (p.length == 0) {
      this._selected = null;
    }
  },

  removeAll: function() {
    this._photos = [];
    this._updateSelected();
    this._notifyChanged();
  },

  remove: function(photo) {
    this._photos = this._photos.filter(function(p) p != photo);
    this._updateSelected();
    this._notifyChanged();
  },

  _ensurePhotoExists: function(photo) {
    var p = this._photos.filter(function(p) p == photo);
    if (p.length == 0) {
      d("ERROR: photo does not exist in set");
      return false;
    }
    if (p.length > 1) {
      d("ERROR: more than one photo matching?");
      return false;
    }
    return true;
  },

  update: function(photo) {
    if (!this._ensurePhotoExists(photo))
      return;

    // The modified photo should be a reference to the photo in the set.
    // So there is nothing to update.

    // There is no listeners for this now. Do not fire the event for perf.
    // TODO: uncomment once there are listener.
    //this._notifyChanged();
  },

  get selected() {
    return this._selected;
  },

  set selected(photo) {
    if (!this._ensurePhotoExists(photo))
      return;
    this._selected = photo;
    this._notifyChanged();
  },

  get photos() {
    return this._photos;
  },

  _notifyChanged: function() {
    this._listeners.forEach(function(listener) {
      listener.call(this);
    }, this);
  },

  addChangedListener: function(aListener) {
    this._listeners.push(aListener);
  },

  removeChangedListener: function(aListener) {
    this._listeners = this._listeners.filter(hasFilter);
    function hasFilter(listener) {
      return listener != aListener;
    }
  },

  _getUploadStream: function(photo, params) {
    const EOL = "\r\n";

    // Header stream.
    var header = "";

    for (let [name, value] in Iterator(params)) {
      header += "--" + BOUNDARY + EOL;
      header += "Content-disposition: form-data; name=\"" + name + "\"" + EOL + EOL;
      header += value;
      header += EOL;
    }
    d("header:\n" + header);

    header += "--" + BOUNDARY + EOL;
    header += "Content-disposition: form-data;name=\"filename\"; filename=\"" +
              photo.file.leafName + "\"" + EOL;
    // Apparently Facebook accepts binay content type and will sniff the file
    // for the correct image mime type.
    header += "Content-Type: application/octet-stream" + EOL;
    header += EOL;

    // Convert the stream to UTF-8, otherwise bad things happen.
    // See http://developer.taboca.com/cases/en/XMLHTTPRequest_post_utf-8/
    var converter = Cc["@mozilla.org/intl/scriptableunicodeconverter"].
                    createInstance(Ci.nsIScriptableUnicodeConverter);
    converter.charset = "UTF-8";
    var headerStream = converter.convertToInputStream(header);

    // Image stream
    const PR_RDONLY = 0x01;
    var fis = new FileInputStream(photo.file, PR_RDONLY, 0444, null);

    var imageStream = Cc["@mozilla.org/network/buffered-input-stream;1"].
                      createInstance(Ci.nsIBufferedInputStream);
    imageStream.init(fis, 4096);

    // Ending stream
    var endingStream = new StringInputStream();
    var boundaryString = "\r\n--" + BOUNDARY + "--\r\n";
    endingStream.setData(boundaryString, boundaryString.length);

    var mis = Cc["@mozilla.org/io/multiplex-input-stream;1"].
              createInstance(Ci.nsIMultiplexInputStream);
    mis.appendStream(headerStream);
    mis.appendStream(imageStream);
    mis.appendStream(endingStream);

    return mis;
  },

  _uploadPhoto: function(albumId, photo, onComplete, onError) {
    var fbSvc = Cc['@facebook.com/facebook-service;1'].
                getService(Ci.fbIFacebookService);

    // Hack for accessing private members.
    var fbSvc_ = fbSvc.wrappedJSObject;
    d("photo is " + photo);

    var params = {};

    // method specific:
    params.method = "facebook.photos.upload";
    if (albumId != DEFAULT_ALBUM)
      params.aid = albumId;
    if (photo.caption)
      params.caption = photo.caption;

    // TODO: this should be refactored with callMethod in the XPCOM component.
    params.session_key = fbSvc_._sessionKey;
    params.api_key = fbSvc.apiKey;
    params.v = "1.0";
    var callId = Date.now();
    if (callId <= fbSvc_._lastCallId) {
        callId = fbSvc_._lastCallId + 1;
    }
    fbSvc_._lastCallId = callId;
    params.call_id = callId;
    params.format = "JSON";

    // Builds another array of params in the format accepted by generateSig()
    var paramsForSig = [];
    for (let [name, value] in Iterator(params)) {
      paramsForSig.push(name + "=" + value);
    }
    params.sig = fbSvc_.generateSig(paramsForSig);

    const RESTSERVER = 'http://api.facebook.com/restserver.php';

    var xhr = new XMLHttpRequest();
    xhr.open("POST", RESTSERVER);

    xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
    xhr.setRequestHeader("MIME-version", "1.0");

    xhr.onreadystatechange = function(event) {
      d("onreadstatechange " + xhr.readyState)
      if (xhr.readyState != 4)
        return;

      try {
        var data = JSON.parse(xhr.responseText);
      } catch(e) {
        onError("Failed to parse JSON", xhr.reponseText);
        return;
      }
      // TODO: refactor with facebook.js::callMethod
      if (typeof data.error_code != "undefined") {
        onError("Server returned an error: " + data.error_msg, data);
        return;
      }
      onComplete();
    }
    xhr.onerror = function(event) {
      onError("XMLHttpRequest error", event);
    }

    // progress on transfers from the server to the client (downloads)
    function updateProgress(evt) {
      d("updateProgress");
    }

    // XXX progress events do not work
    xhr.onprogress = updateProgress;
    // The upload property is not available with Firefox 3.0
    if (xhr.upload)
      xhr.upload.onprogress = updateProgress;

    xhr.send(this._getUploadStream(photo, params));
  },

  upload: function(albumId, progressCallback, errorCallback) {
    var toUpload = this._photos;
    var total = toUpload.length;
    var index = 0;
    var self = this;

    function doUpload() {
      if (self._cancelled) {
        d("Upload cancelled");
        progressCallback(100, true);
        return;
      }
      if (index == total) {
        d("How could that happen?");
        return;
      }
      var photo = toUpload[index];
      if (!photo) {
        d("How could that happen?");
        return;
      }

      self._uploadPhoto(albumId, photo, function() {
        index++;
        progressCallback(index / total * 100, false);
        if (index == total) {
          self.removeAll();
        } else {
          doUpload();
        }
      }, function() {
        errorCallback.apply(this, arguments);
      });
    }
    doUpload();
  },

  cancelUpload: function() {
    this._cancelled = true;
  }
};

/**
 * Manages the UI for displaying and manipulating the list of photos.
 */
var OverviewPanel = {
  init: function() {
    PhotoSet.addChangedListener(this.photosChanged);
  },
  uninit: function() {
    PhotoSet.removeChangedListener(this.photosChanged);
  },
  photosChanged: function() {
    d("PhotosChanged ");

    var panelDoc = document.getElementById("overviewPanel").contentDocument;
    var photoContainer = panelDoc.getElementById("photo-container")
    var photoboxTemplate = panelDoc.getElementById("photobox-template")
    var photos = PhotoSet.photos;

    var node = photoContainer.firstChild;
    while (node) {
      var nextNode = node.nextSibling;
      if (node.nodeType == Node.ELEMENT_NODE &&
          node.className == "photobox" &&
          node.id != "photobox-template") {
        photoContainer.removeChild(node);
      }
      node = nextNode;
    }

    photos.forEach(function(photo) {
      var newBox = photoboxTemplate.cloneNode(true);
      newBox.photo = photo;
      newBox.removeAttribute("id");
      if (photo == PhotoSet.selected)
        newBox.setAttribute("selected", "true");

      newBox.getElementsByTagName("img")[0].src = photo.url;
      photoboxTemplate.parentNode.insertBefore(newBox, photoboxTemplate);
    });
  },
  _photoFromEvent: function(event) {
    event.stopPropagation();
    var node = event.target;
    while (node) {
      if (node.photo)
        return node.photo;
      node = node.parentNode;
    }
    return null;
  },
  selectPhoto: function(event) {
    var photo = this._photoFromEvent(event);
    if (!photo) {
      d("Error, photo not found");
      return;
    }
    PhotoSet.selected = photo;
  },
  removePhoto: function(event) {
    var photo = this._photoFromEvent(event);
    if (!photo) {
      d("Error, photo not found");
      return;
    }
    PhotoSet.remove(photo);
  }
};

/**
 * The panel that shows the selected photo where attributes can be edited.
 */
var EditPanel = {
  init: function() {
    PhotoSet.addChangedListener(this.photosChanged);
  },
  uninit: function() {
    PhotoSet.removeChangedListener(this.photosChanged);
  },
  photosChanged: function() {
    d("editPanel: PhotosChanged");

    var editImageFrame = document.getElementById("editImageFrame");
    var imageElement = editImageFrame.contentDocument.getElementById("image");
    var captionField = document.getElementById("editCaptionField");

    imageElement.removeAttribute("hidden");
    captionField.disabled = false;
    if (!PhotoSet.selected) {
      imageElement.setAttribute("hidden", "true");
      captionField.value = "";
      captionField.disabled = true;
      return;
    }

    var selectedPhoto = PhotoSet.selected;
    imageElement.setAttribute("src", selectedPhoto.url);
    captionField.value = selectedPhoto.caption;
  },
  onCaptionInput: function(event) {
    var selectedPhoto = PhotoSet.selected;
    if (!selectedPhoto)
      return;

    selectedPhoto.caption = event.target.value;
    PhotoSet.update(selectedPhoto);
  }
};

var PhotoDNDObserver = {
  getSupportedFlavours : function () {
    var flavours = new FlavourSet();
    flavours.appendFlavour("text/x-moz-url");
    flavours.appendFlavour("application/x-moz-file",  "nsIFile");
    return flavours;
  },

  _getFileFromDragSession: function (session, position) {
    var fileData = { };
    var ios = Cc["@mozilla.org/network/io-service;1"].
              getService(Ci.nsIIOService);
    // if this fails we do not have valid data to drop
    try {
      var xfer = Cc["@mozilla.org/widget/transferable;1"].
                 createInstance(Ci.nsITransferable);
      xfer.addDataFlavor("text/x-moz-url");
      xfer.addDataFlavor("application/x-moz-file", "nsIFile");
      session.getData(xfer, position);

      var flavour = { }, data = { }, length = { };
      xfer.getAnyTransferData(flavour, data, length);
      var selectedFlavour = this.getSupportedFlavours().flavourTable[flavour.value];
      var xferData = new FlavourData(data.value, length.value, selectedFlavour);

      var fileURL = transferUtils.retrieveURLFromData(xferData.data,
                                                      xferData.flavour.contentType);
      var file = ios.newURI(fileURL, null, null).QueryInterface(Ci.nsIFileURL).file;
    } catch (e) {
      d("Exception while getting drag data: " + e);
      return null;
    }
    return file;
  },

  onDrop: function (event, dropdata, session) {
    var count = session.numDropItems;
    var files = [];
    for (var i = 0; i < count; ++i) {
      var file = this._getFileFromDragSession(session, i);
      if (file)
        files.push(file);
    }
    PhotoSet.add([new Photo(f) for each (f in files)]);
  }
};

const NEW_ALBUM = 0;
const EXISTING_ALBUM = 1;

const POST_UPLOAD_ASKUSER = 0;
const POST_UPLOAD_OPENALBUM = 1;
const POST_UPLOAD_STAYHERE = 2;

/**
 * Manages the Photo upload window.
 */
var PhotoUpload = {
  get _stringBundle() {
    delete this._stringBundle;
    return this._stringBundle = document.getElementById("facebookStringBundle");
  },

  get _fbSvc() {
    delete this._fbSvc;
    return this._fbSvc = Cc['@facebook.com/facebook-service;1'].
                         getService(Ci.fbIFacebookService);
  },

  _url: function(spec) {
    var ios = Cc["@mozilla.org/network/io-service;1"].
              getService(Ci.nsIIOService);
    return ios.newURI(spec, null, null);
  },

  init: function() {
    OverviewPanel.init();
    EditPanel.init();
    PhotoSet.addChangedListener(this.photosChanged);

    var albumsPopup = document.getElementById("albumsPopup");
    var self = this;
    this._getAlbums(function(albums) {

      var lastAlbumId = document.getElementById("albumsList")
                                .getAttribute("lastalbumid");
      var selectedItem;
      for each (var album in albums) {
        var menuitem = document.createElement("menuitem");
        menuitem.setAttribute("label", album.name);
        menuitem.setAttribute("albumid", album.aid);
        if (album.aid == lastAlbumId)
          selectedItem = menuitem;
        d("Album name: " + album.name + " album id: " + album.aid);
        albumsPopup.appendChild(menuitem);
      }
      if (selectedItem) {
        var albumsList = document.getElementById("albumsList");
        albumsList.selectedItem = selectedItem;
      }
      self._checkPhotoUploadPermission();
    });

    // XXX debug
    /*
    document.getElementById("reopenButton").hidden = false;
    var file, files = [];
    file = Cc["@mozilla.org/file/local;1"].
           createInstance(Ci.nsILocalFile);
    file.initWithPath("/home/sypasche/projects/facebook/sample_images/metafont.png");
    //file.initWithPath("/home/sypasche/projects/facebook/sample_images/very_wide.png");
    files.push(file);
    file = Cc["@mozilla.org/file/local;1"].
           createInstance(Ci.nsILocalFile);
    //file.initWithPath("/home/sypasche/projects/facebook/sample_images/recycled.png");
    file.initWithPath("/home/sypasche/projects/facebook/sample_images/very_tall.png");
    files.push(file);

    var file = Cc["@mozilla.org/file/local;1"].
               createInstance(Ci.nsILocalFile);
    file.initWithPath("/home/sypasche/projects/facebook/sample_images/hot-2560x1280.jpg");
    files.push(file);
    var photos = [new Photo(f) for each (f in files)];
    d("photos " + photos);
    PhotoSet.add(photos);
    PhotoSet.selected = photos[2];
    */
  },

  uninit: function() {
    OverviewPanel.uninit();
    EditPanel.uninit();
    PhotoSet.removeChangedListener(this.photosChanged);
    if (this.getAlbumSelectionMode() == EXISTING_ALBUM) {
      var albumsList = document.getElementById("albumsList");
      var albumId = albumsList.selectedItem.getAttribute("albumid");
      document.getElementById("albumsList").setAttribute("lastalbumid", albumId);
    }
    document.persist("albumsList", "lastalbumid");
  },

  _checkPhotoUploadPermission: function() {
    d("Checking photo upload permission");
    const PERM = "photo_upload";

    var self = this;
    // XXX wrappedJSObject hack because the method is not exposed.
    this._fbSvc.wrappedJSObject.callMethod('facebook.users.hasAppPermission',
                                           ['ext_perm=' + PERM],
                                           function(data) {
      if ('1' == data.toString()) {
        d("photo upload is authorized");
        return;
      }

      let promptTitle = self._stringBundle.getString("allowUploadTitle");
      let promptMessage = self._stringBundle.getString("allowUploadMessage");
      let openAuthorize = self._stringBundle.getString("openAuthorizePage");

      const IPS = Ci.nsIPromptService;
      let ps = Cc["@mozilla.org/embedcomp/prompt-service;1"].getService(IPS);
      let rv = ps.confirmEx(window, promptTitle, promptMessage,
                            (IPS.BUTTON_TITLE_IS_STRING * IPS.BUTTON_POS_0) +
                            (IPS.BUTTON_TITLE_CANCEL * IPS.BUTTON_POS_1),
                            openAuthorize, null, null, null, {value: 0});

      if (rv != 0)
        return;
      var authorizeUrl = "http://www.facebook.com/authorize.php?api_key=" +
                         self._fbSvc.apiKey +"&v=1.0&ext_perm=" + PERM;
      Application.activeWindow.open(self._url(authorizeUrl)).focus();
      window.close();
    });
  },

  photosChanged: function() {
    document.getElementById("uploadButton").disabled = PhotoSet.photos.length == 0;
  },

  getAlbumSelectionMode: function() {
    var albumSelectionGroup = document.getElementById("albumSelectionGroup");
    var existingAlbumRadio = document.getElementById("existingAlbumRadio");
    var newAlbumRadio = document.getElementById("newAlbumRadio");

    if (albumSelectionGroup.selectedItem == existingAlbumRadio)
      return EXISTING_ALBUM;
    if (albumSelectionGroup.selectedItem == newAlbumRadio)
      return NEW_ALBUM;

    throw "Unknown album selection mode";
  },

  onAlbumSelectionModeChange: function() {
    var albumSelectionDeck = document.getElementById("albumSelectionDeck");
    var selectionMode = this.getAlbumSelectionMode();

    if (selectionMode == EXISTING_ALBUM) {
      albumSelectionDeck.selectedPanel =
        document.getElementById("existingAlbumPanel");
    } else if (selectionMode == NEW_ALBUM) {
      albumSelectionDeck.selectedPanel =
        document.getElementById("newAlbumPanel");
    }
  },

  _getAlbums: function(callback) {
    // XXX wrappedJSObject hack because the method is not exposed.
    this._fbSvc.wrappedJSObject.callMethod('facebook.photos.getAlbums',
                                     ["uid=" + this._fbSvc.wrappedJSObject._uid],
                                     callback
    );
  },

  addPhotos: function() {
    var fp = Cc["@mozilla.org/filepicker;1"].
             createInstance(Ci.nsIFilePicker);
    fp.init(window, this._stringBundle.getString("filePickerTitle"),
            Ci.nsIFilePicker.modeOpenMultiple);
    fp.appendFilters(Ci.nsIFilePicker.filterImages);
    if (fp.show() != Ci.nsIFilePicker.returnCancel) {
      var photos = [];
      var filesEnum = fp.files;
      while (filesEnum.hasMoreElements()) {
        photos.push(new Photo(filesEnum.getNext()));
      }
      PhotoSet.add(photos);
    }
  },

  removeAllPhotos: function() {
    PhotoSet.removeAll();
  },

  cancelUpload: function() {
    PhotoSet.cancelUpload();
  },

  /**
   * Converts the album id that is used in the Facebook API to the album id
   * that is used in the aid GET parameter of the editalbum.php page.
   */
  _albumIdToUrlAlbumId: function(albumId) {
    // the url album id is the least significant 32 bits of the api-generated
    // album id, the user id is the most significant 32 bits.

    // Javascript Number are 64bit floating point. The albumid is a 64bit integer.
    // That number is too big to be handled directly without loss of precision,
    // so we use an external library for calculation.
    var id = new BigInteger(albumId, 10);
    var mask = new BigInteger("ffffffff", 16);
    var urlAlbumId = id.and(mask);
    return urlAlbumId.toString(10);
  },

  _postUpload: function(albumId) {
    var prefSvc = Cc['@mozilla.org/preferences-service;1'].getService(Ci.nsIPrefBranch);
    var postUploadAction = prefSvc.getIntPref("extensions.facebook.postuploadaction");

    if (postUploadAction == POST_UPLOAD_ASKUSER) {
      let promptTitle = this._stringBundle.getString("uploadCompleteTitle");
      let promptMessage = this._stringBundle.getString("uploadCompleteMessage");
      let checkboxLabel = this._stringBundle.getString("rememberDecision");
      let goToAlbum = this._stringBundle.getString("goToAlbum");
      let stayHere = this._stringBundle.getString("stayHere");

      const IPS = Ci.nsIPromptService;
      let ps = Cc["@mozilla.org/embedcomp/prompt-service;1"].getService(IPS);
      let remember = { value: false };
      let rv = ps.confirmEx(window, promptTitle, promptMessage,
                            (IPS.BUTTON_TITLE_IS_STRING * IPS.BUTTON_POS_0) +
                            (IPS.BUTTON_TITLE_IS_STRING * IPS.BUTTON_POS_1),
                            goToAlbum, stayHere, null, checkboxLabel, remember);

      postUploadAction = rv == 0 ? POST_UPLOAD_OPENALBUM : POST_UPLOAD_STAYHERE;
      if (remember.value) {
        prefSvc.setIntPref("extensions.facebook.postuploadaction", postUploadAction);
      }
    }
    if (postUploadAction == POST_UPLOAD_STAYHERE)
      return;

    if (postUploadAction == POST_UPLOAD_OPENALBUM) {
      var aid = "";
      // TODO: what should the URL be in this case?
      if (albumId != DEFAULT_ALBUM)
        aid = "aid=" + this._albumIdToUrlAlbumId(albumId) + "&";
      Application.activeWindow.open(
        this._url("http://www.facebook.com/editalbum.php?" + aid + "org=1")).focus();
      window.close();
    }
  },

  upload: function() {
    if (PhotoSet.photos.length == 0) {
      // This shouldn't happen (button is disabled when there are no photos).
      return;
    }

    var albumId = DEFAULT_ALBUM;
    var selectionMode = this.getAlbumSelectionMode();
    if (selectionMode == NEW_ALBUM) {
      alert("Album creation not yet implemented");
      // TODO
      return;
    } else if (selectionMode == EXISTING_ALBUM) {
      var albumsList = document.getElementById("albumsList");
      albumId = albumsList.selectedItem.getAttribute("albumid");
    } else {
      throw "Unexpected selection mode";
    }

    d("album id: " + albumId);

    var uploadStatus = document.getElementById("uploadStatus")
    var uploadStatusDeck = document.getElementById("uploadStatusDeck");
    var progress = document.getElementById("uploadProgress");

    uploadStatusDeck.selectedIndex = 1;
    var uploadBroadcaster = document.getElementById("uploadBroadcaster");
    uploadBroadcaster.setAttribute("disabled", "true");
    uploadStatus.className = "upload-status";
    uploadStatus.value = "";

    function uploadDone() {
      progress.value = 0;
      uploadBroadcaster.setAttribute("disabled", "false");
      uploadStatusDeck.selectedIndex = 0;
    }

    var self = this;
    PhotoSet.upload(albumId, function(percent, cancelled) {
      d("Got progress " + percent);

      progress.value = percent;
      if (percent < 100)
        return;
      uploadDone();

      if (cancelled) {
        uploadStatus.value = self._stringBundle.getString("uploadCancelled");
      } else {
        uploadStatus.value = self._stringBundle.getString("uploadComplete");
      }
      self._postUpload(albumId);

    }, function(message, detail) {
      uploadDone();
      alert(self._stringBundle.getString("uploadFailedAlert") + " " + message);
      uploadStatus.className += " error";
      uploadStatus.value = self._stringBundle.getString("uploadFailedStatus") +
                           " " + message;
    });
  }
};
