/**
 * Facebook Firefox Toolbar Software License
 * Copyright (c) 2009 Facebook, Inc.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (which, together with any graphical images included with such
 * software, are collectively referred to below as the "Software") to (a) use,
 * reproduce, display, distribute, execute, and transmit the Software, (b)
 * prepare derivative works of the Software (excluding any graphical images
 * included with the Software, which may not be modified or altered), and (c)
 * permit third-parties to whom the Software is furnished to do so, all
 * subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * Facebook, Inc. retains ownership of the Software and all associated
 * intellectual property rights.  All rights not expressly granted in this
 * license are reserved by Facebook, Inc.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const Cc = Components.classes;
const Ci = Components.interfaces;
const CC = Components.Constructor;
const Cu = Components.utils;

const FileInputStream = CC("@mozilla.org/network/file-input-stream;1",
                           "nsIFileInputStream",
                           "init");
const StringInputStream = CC("@mozilla.org/io/string-input-stream;1",
                             "nsIStringInputStream")

// Keep this in sync with the albumid attribute of the default album in photoupload.xul
const DEFAULT_ALBUM = "-1";

// Compatibility with Firefox 3.0 that doesn't have native JSON.
// TODO: remove this once the Facebook component is used for requests.
if (typeof(JSON) == "undefined") {
  Components.utils.import("resource://gre/modules/JSON.jsm");
  JSON.parse = JSON.fromString;
  JSON.stringify = JSON.toString;
}

// Debugging.
function d(s) {
  dump(s + "\n");
}

/**
 * This object (singleton) represent the list of photos that will be uploaded
 * or that can be edited.
 */
var PhotoSet = {
  // XXX photos are nsIFile objects now. This may change once resizing or
  // metadata editing is implemented.
  _photos: [],
  _listeners: [],
  _cancelled: false,

  add: function(aFiles) {
    Array.prototype.push.apply(this._photos, aFiles)

    this._notifyChanged();
  },

  removeAll: function() {
    this._photos = [];
    this._notifyChanged();
  },

  remove: function(photo) {
    this._photos = this._photos.filter(function(p) p != photo);
    this._notifyChanged();
  },

  get photos() {
    return this._photos;
  },

  _notifyChanged: function() {
    this._listeners.forEach(function(listener) {
      listener.call(this);
    }, this);
  },

  addChangedListener: function(aListener) {
    this._listeners.push(aListener);
  },

  removeChangedListener: function(aListener) {
    this._listeners = this._listeners.filter(hasFilter);
    function hasFilter(listener) {
      return listener != aListener;
    }
  },

  _uploadFile: function(albumId, file, onComplete, onError) {
    var fbSvc = Cc['@facebook.com/facebook-service;1'].
                getService(Ci.fbIFacebookService);

    // Hack for accessing private members.
    var fbSvc_ = fbSvc.wrappedJSObject;
    d("file is " + file);

    var params = {};

    // method specific:
    params.method = "facebook.photos.upload";
    if (albumId != DEFAULT_ALBUM)
      params.aid = albumId;

    // TODO: this should be refactored with callMethod in the XPCOM component.
    params.session_key = fbSvc_._sessionKey;
    params.api_key = fbSvc.apiKey;
    params.v = "1.0";
    var callId = Date.now();
    if (callId <= fbSvc_._lastCallId) {
        callId = fbSvc_._lastCallId + 1;
    }
    fbSvc_._lastCallId = callId;
    params.call_id = callId;
    params.format = "JSON";

    // Builds another array of params in the format accepted by generateSig()
    var paramsForSig = [];
    for (let [name, value] in Iterator(params)) {
      paramsForSig.push(name + "=" + value);
    }
    params.sig = fbSvc_.generateSig(paramsForSig);

    const BOUNDARY = "facebookPhotoUploaderBoundary";

    var mis = Cc["@mozilla.org/io/multiplex-input-stream;1"].
              createInstance(Ci.nsIMultiplexInputStream);

    const PR_RDONLY = 0x01;
    var fis = new FileInputStream(file, PR_RDONLY, 0444, null);

    var bis = Cc["@mozilla.org/network/buffered-input-stream;1"].
              createInstance(Ci.nsIBufferedInputStream);
    bis.init(fis, 4096);

    var sis = new StringInputStream();
    var header = "";

    for (let [name, value] in Iterator(params)) {
      header += "--" + BOUNDARY + "\r\n";
      header += "Content-disposition: form-data; name=\"" + name + "\"\r\n\r\n";
      header += value;
      header += "\r\n";
    }

    d("header:\n" + header);

    header += "--" + BOUNDARY + "\r\n";
    header += "Content-disposition: form-data;name=\"filename\"; filename=\"" +
              file.leafName + "\"\r\n";
    // Apparently Facebook accepts binay content type and will sniff the file
    // for the correct image mime type.
    header += "Content-Type: application/octet-stream\r\n";
    header += "\r\n";

    sis.setData(header, header.length);

    var endsis = new StringInputStream();
    var bs = "\r\n--" + BOUNDARY + "--\r\n";
    endsis.setData(bs, bs.length);

    mis.appendStream(sis);
    mis.appendStream(bis);
    mis.appendStream(endsis);

    var xhr = new XMLHttpRequest();

    const RESTSERVER = 'http://api.facebook.com/restserver.php';
    xhr.open("POST", RESTSERVER);

    xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
    xhr.setRequestHeader("MIME-version", "1.0");

    xhr.onreadystatechange = function(event) {
      d("onreadstatechange " + xhr.readyState)
      if (xhr.readyState != 4)
        return;

      // XXX 3.0 compat
      try {
        var data = JSON.parse(xhr.responseText);
      } catch(e) {
        onError("Failed to parse JSON", xhr.reponseText);
        return;
      }
      // TODO: refactor with facebook.js::callMethod
      if (typeof data.error_code != "undefined") {
        onError("Server returned an error: " + data.error_msg, data);
        return;
      }
      onComplete();
    }
    xhr.onerror = function(event) {
      onError("XMLHttpRequest error", event);
    }

    // progress on transfers from the server to the client (downloads)
    function updateProgress(evt) {
      d("updateProgress");
    }

    // XXX progress events do not work
    xhr.onprogress = updateProgress;
    // The upload property is not available with Firefox 3.0
    if (xhr.upload)
      xhr.upload.onprogress = updateProgress;

    xhr.send(mis);
  },

  upload: function(albumId, progressCallback, errorCallback) {
    var toUpload = this._photos;
    var total = toUpload.length;
    var done = 0;
    var self = this;

    function uploadDone() {
      self._photos = [];
      self._notifyChanged();
    }

    function doUpload() {
      if (self._cancelled) {
        d("Upload cancelled");
        progressCallback(100, true);
        return;
      }
      if (done == total) {
        d("How could that happen?");
        return;
      }
      var photo = toUpload.shift();
      if (!photo) {
        d("How could that happen?");
        return;
      }

      self._uploadFile(albumId, photo, function() {
        done++;
        progressCallback(done / total * 100, false);
        if (done == total) {
          uploadDone();
        } else {
          doUpload();
        }
      }, function() {
        errorCallback.apply(this, arguments);
      });
    }
    doUpload();
  },

  cancelUpload: function() {
    this._cancelled = true;
  }
};

/**
 * Manages the UI for displaying and manipulating the list of photos.
 */
var PhotoPanel = {
  init: function() {
    PhotoSet.addChangedListener(this.photosChanged);
  },
  uninit: function() {
    PhotoSet.removeChangedListener(this.photosChanged);
  },
  photosChanged: function() {
    d("PhotosChanged ");

    var panelDoc = document.getElementById("photopanel").contentDocument;
    var photoContainer = panelDoc.getElementById("photo-container")
    var photoboxTemplate = panelDoc.getElementById("photobox-template")
    var photos = PhotoSet.photos;

    var node = photoContainer.firstChild;
    while (node) {
      var nextNode = node.nextSibling;
      if (node.nodeType == Node.ELEMENT_NODE &&
          node.className == "photobox" &&
          node.id != "photobox-template") {
        photoContainer.removeChild(node);
      }
      node = nextNode;
    }

    var ios = Cc["@mozilla.org/network/io-service;1"].
              getService(Ci.nsIIOService);

    photos.forEach(function(photo) {
      var newBox = photoboxTemplate.cloneNode(true);
      newBox.photo = photo;
      newBox.removeAttribute("id");

      var uri = ios.newFileURI(photo);
      newBox.getElementsByTagName("img")[0].src = uri.spec;
      photoboxTemplate.parentNode.insertBefore(newBox, photoboxTemplate);
    });
  },
  removePhoto: function(event) {
    var photoBox = event.target.parentNode;
    var photo = photoBox.photo;
    if (!photo) {
      d("Error, photo not found");
      return;
    }
    PhotoSet.remove(photo);
  }
};

const NEW_ALBUM = 0;
const EXISTING_ALBUM = 1;

const POST_UPLOAD_ASKUSER = 0;
const POST_UPLOAD_OPENALBUM = 1;
const POST_UPLOAD_STAYHERE = 2;

/**
 * Manages the Photo upload window.
 */
var PhotoUpload = {
  get _stringBundle() {
    delete this._stringBundle;
    return this._stringBundle = document.getElementById("facebookStringBundle");
  },

  get _fbSvc() {
    delete this._fbSvc;
    return this._fbSvc = Cc['@facebook.com/facebook-service;1'].
                         getService(Ci.fbIFacebookService);
  },

  _url: function(spec) {
    var ios = Cc["@mozilla.org/network/io-service;1"].
              getService(Ci.nsIIOService);
    return ios.newURI(spec, null, null);
  },

  init: function() {
    PhotoPanel.init();
    PhotoSet.addChangedListener(this.photosChanged);

    var albumsPopup = document.getElementById("albumsPopup");
    var self = this;
    this._getAlbums(function(albums) {

      var lastAlbumId = document.getElementById("albumsList")
                                .getAttribute("lastalbumid");
      var selectedItem;
      for each (var album in albums) {
        var menuitem = document.createElement("menuitem");
        menuitem.setAttribute("label", album.name);
        menuitem.setAttribute("albumid", album.aid);
        if (album.aid == lastAlbumId)
          selectedItem = menuitem;
        d("Album name: " + album.name + " album id: " + album.aid);
        albumsPopup.appendChild(menuitem);
      }
      if (selectedItem) {
        var albumsList = document.getElementById("albumsList");
        albumsList.selectedItem = selectedItem;
      }
      self._checkPhotoUploadPermission();
    });

    // XXX debug
    /*
    var file = Cc["@mozilla.org/file/local;1"].
               createInstance(Ci.nsILocalFile);
    file.initWithPath("/home/sypasche/projects/facebook/sample_images/metafont.png");
    var file2 = Cc["@mozilla.org/file/local;1"].
                createInstance(Ci.nsILocalFile);
    file2.initWithPath("/home/sypasche/projects/facebook/sample_images/recycled.png");
    PhotoSet.add([file, file2]);
    */
  },

  uninit: function() {
    PhotoPanel.uninit();
    PhotoSet.removeChangedListener(this.photosChanged);
    if (this.getAlbumSelectionMode() == EXISTING_ALBUM) {
      var albumsList = document.getElementById("albumsList");
      var albumId = albumsList.selectedItem.getAttribute("albumid");
      document.getElementById("albumsList").setAttribute("lastalbumid", albumId);
    }
    document.persist("albumsList", "lastalbumid");
  },

  _checkPhotoUploadPermission: function() {
    d("Checking photo upload permission");
    const PERM = "photo_upload";

    var self = this;
    // XXX wrappedJSObject hack because the method is not exposed.
    this._fbSvc.wrappedJSObject.callMethod('facebook.users.hasAppPermission',
                                           ['ext_perm=' + PERM],
                                           function(data) {
      if ('1' == data.toString()) {
        d("photo upload is authorized");
        return;
      }

      let promptTitle = self._stringBundle.getString("allowUploadTitle");
      let promptMessage = self._stringBundle.getString("allowUploadMessage");
      let openAuthorize = self._stringBundle.getString("openAuthorizePage");

      const IPS = Ci.nsIPromptService;
      let ps = Cc["@mozilla.org/embedcomp/prompt-service;1"].getService(IPS);
      let rv = ps.confirmEx(window, promptTitle, promptMessage,
                            (IPS.BUTTON_TITLE_IS_STRING * IPS.BUTTON_POS_0) +
                            (IPS.BUTTON_TITLE_CANCEL * IPS.BUTTON_POS_1),
                            openAuthorize, null, null, null, {value: 0});

      if (rv != 0)
        return;
      var authorizeUrl = "http://www.facebook.com/authorize.php?api_key=" +
                         self._fbSvc.apiKey +"&v=1.0&ext_perm=" + PERM;
      Application.activeWindow.open(self._url(authorizeUrl)).focus();
      window.close();
    });
  },

  photosChanged: function() {
    document.getElementById("uploadButton").disabled = PhotoSet.photos.length == 0;
  },

  getAlbumSelectionMode: function() {
    var albumSelectionGroup = document.getElementById("albumSelectionGroup");
    var existingAlbumRadio = document.getElementById("existingAlbumRadio");
    var newAlbumRadio = document.getElementById("newAlbumRadio");

    if (albumSelectionGroup.selectedItem == existingAlbumRadio)
      return EXISTING_ALBUM;
    if (albumSelectionGroup.selectedItem == newAlbumRadio)
      return NEW_ALBUM;

    throw "Unknown album selection mode";
  },

  onAlbumSelectionModeChange: function() {
    var albumSelectionDeck = document.getElementById("albumSelectionDeck");
    var selectionMode = this.getAlbumSelectionMode();

    if (selectionMode == EXISTING_ALBUM) {
      albumSelectionDeck.selectedPanel =
        document.getElementById("existingAlbumPanel");
    } else if (selectionMode == NEW_ALBUM) {
      albumSelectionDeck.selectedPanel =
        document.getElementById("newAlbumPanel");
    }
  },

  _getAlbums: function(callback) {
    // XXX wrappedJSObject hack because the method is not exposed.
    this._fbSvc.wrappedJSObject.callMethod('facebook.photos.getAlbums',
                                     ["uid=" + this._fbSvc.wrappedJSObject._uid],
                                     callback
    );
  },

  addPhotos: function() {
    var fp = Cc["@mozilla.org/filepicker;1"].
             createInstance(Ci.nsIFilePicker);
    fp.init(window, this._stringBundle.getString("filePickerTitle"),
            Ci.nsIFilePicker.modeOpenMultiple);
    fp.appendFilters(Ci.nsIFilePicker.filterImages);
    if (fp.show() != Ci.nsIFilePicker.returnCancel) {
      var files = [];
      var filesEnum = fp.files;
      while (filesEnum.hasMoreElements()) {
        files.push(filesEnum.getNext());
      }
      PhotoSet.add(files);
    }
  },

  removeAllPhotos: function() {
    PhotoSet.removeAll();
  },

  cancelUpload: function() {
    PhotoSet.cancelUpload();
  },

  /**
   * Converts the album id that is used in the Facebook API to the album id
   * that is used in the aid GET parameter of the editalbum.php page.
   */
  _albumIdToUrlAlbumId: function(albumId) {
    // the url album id is the least significant 32 bits of the api-generated
    // album id, the user id is the most significant 32 bits.

    // Javascript Number are 64bit floating point. The albumid is a 64bit integer.
    // That number is too big to be handled directly without loss of precision,
    // so we use an external library for calculation.
    var id = new BigInteger(albumId, 10);
    var mask = new BigInteger("ffffffff", 16);
    var urlAlbumId = id.and(mask);
    return urlAlbumId.toString(10);
  },

  _postUpload: function(albumId) {

    var prefSvc = Cc['@mozilla.org/preferences-service;1'].getService(Ci.nsIPrefBranch);
    var postUploadAction = prefSvc.getIntPref("extensions.facebook.postuploadaction");

    if (postUploadAction == POST_UPLOAD_ASKUSER) {

      let promptTitle = this._stringBundle.getString("uploadCompleteTitle");
      let promptMessage = this._stringBundle.getString("uploadCompleteMessage");
      let checkboxLabel = this._stringBundle.getString("rememberDecision");
      let goToAlbum = this._stringBundle.getString("goToAlbum");
      let stayHere = this._stringBundle.getString("stayHere");

      const IPS = Ci.nsIPromptService;
      let ps = Cc["@mozilla.org/embedcomp/prompt-service;1"].getService(IPS);
      let remember = { value: false };
      let rv = ps.confirmEx(window, promptTitle, promptMessage,
                            (IPS.BUTTON_TITLE_IS_STRING * IPS.BUTTON_POS_0) +
                            (IPS.BUTTON_TITLE_IS_STRING * IPS.BUTTON_POS_1),
                            goToAlbum, stayHere, null, checkboxLabel, remember);

      postUploadAction = rv == 0 ? POST_UPLOAD_OPENALBUM : POST_UPLOAD_STAYHERE;
      if (remember.value) {
        prefSvc.setIntPref("extensions.facebook.postuploadaction", postUploadAction);
      }
    }
    if (postUploadAction == POST_UPLOAD_STAYHERE)
      return;

    if (postUploadAction == POST_UPLOAD_OPENALBUM) {
      var aid = "";
      // TODO: what should the URL be in this case?
      if (albumId != DEFAULT_ALBUM)
        aid = "aid=" + this._albumIdToUrlAlbumId(albumId) + "&";
      Application.activeWindow.open(
        this._url("http://www.facebook.com/editalbum.php?" + aid + "org=1")).focus();
      window.close();
    }
  },

  upload: function() {
    if (PhotoSet.photos.length == 0) {
      // This shouldn't happen (button is disabled when there are no photos).
      return;
    }

    var albumId = DEFAULT_ALBUM;
    var selectionMode = this.getAlbumSelectionMode();
    if (selectionMode == NEW_ALBUM) {
      alert("Album creation not yet implemented");
      // TODO
      return;
    } else if (selectionMode == EXISTING_ALBUM) {
      var albumsList = document.getElementById("albumsList");
      albumId = albumsList.selectedItem.getAttribute("albumid");
    } else {
      throw "Unexpected selection mode";
    }

    d("album id: " + albumId);

    var uploadStatus = document.getElementById("uploadStatus")
    var uploadStatusDeck = document.getElementById("uploadStatusDeck");
    var progress = document.getElementById("uploadProgress");

    uploadStatusDeck.selectedIndex = 1;
    var uploadBroadcaster = document.getElementById("uploadBroadcaster");
    uploadBroadcaster.setAttribute("disabled", "true");
    uploadStatus.className = "upload-status";
    uploadStatus.value = "";

    function uploadDone() {
      progress.value = 0;
      uploadBroadcaster.setAttribute("disabled", "false");
      uploadStatusDeck.selectedIndex = 0;
      document.getElementById("uploadButton").disabled = true;
    }

    var self = this;
    PhotoSet.upload(albumId, function(percent, cancelled) {
      d("Got progress " + percent);

      progress.value = percent;
      if (percent < 100)
        return;
      uploadDone();

      if (cancelled) {
        uploadStatus.value = self._stringBundle.getString("uploadCancelled");
      } else {
        uploadStatus.value = self._stringBundle.getString("uploadComplete");
      }
      self._postUpload(albumId);

    }, function(message, detail) {
      uploadDone();
      alert(self._stringBundle.getString("uploadFailedAlert") + " " + message);
      uploadStatus.className += " error";
      uploadStatus.value = self._stringBundle.getString("uploadFailedStatus") +
                           " " + message;
    });
  }
};
